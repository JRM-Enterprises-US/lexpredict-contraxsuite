# Generated by Django 2.2.10 on 2020-04-20 15:04

from django.db import migrations, connection


def run_migration(apps, schema_editor):
    with connection.cursor() as cursor:
        cursor.execute('''
create extension if not exists hstore;

create or replace function task_status_precedence(status varchar = 'PENDING') returns int as $$
    declare
        res int = 1;
        precedence hstore := 'PENDING=>1, RETRY=>2, REJECTED=>3, RECEIVED=>4, STARTED=>5, REVOKED=>6, FAILURE=>7, SUCCESS=>8'::hstore;
    begin
        if status is null then
            return 1;
        else
            res := precedence -> status;
            if res is null then
                return 1;
            else
                return res;
            end if;
        end if;
    end;
$$ language plpgsql;

create or replace function task_status_to_str(status int = null) returns varchar as $$
    declare
        res int = 1;
        precedence varchar array[8] := ARRAY['PENDING', 'RETRY', 'REJECTED', 'RECEIVED', 'STARTED', 'REVOKED', 'FAILURE', 'SUCCESS'];
    begin
        if status is null or status < 1 or status > 8 then
            return 'PENDING';
        else
            return precedence[status];
        end if;
    end;
$$ language plpgsql;


create or replace function calc_task_status(src_id varchar, src_own_status varchar, src_has_sub_tasks boolean) returns int as $$
    begin
        if not src_has_sub_tasks then
            return task_status_precedence(src_own_status);
        else
            return (select min(case when ch.id = src_id 
                                    then task_status_precedence(ch.own_status) 
                                    else calc_task_status(ch.id, ch.own_status, ch.has_sub_tasks)
                                    end) 
                        from task_task ch 
                        where     not ch.run_if_parent_task_failed 
                              and (ch.parent_task_id = src_id or ch.id = src_id));
        end if;
    end;
$$ language plpgsql;

      
create or replace function fix_task_progress_with_status(src_progress float, src_status int) returns float as $$
    declare
        first_finished_status constant int := 6;
    begin
        if src_status >= first_finished_status then
            return 100;
        else
            return src_progress;
        end if;
    end;
$$ language plpgsql;
  
        
create or replace function calc_task_progress(src_id varchar, 
                                              src_own_progress int, 
                                              src_own_status varchar,
                                              src_has_sub_tasks boolean) returns float as $$
    begin
        if not src_has_sub_tasks then
            return fix_task_progress_with_status(greatest(0, least(coalesce(src_own_progress, 0), 100)), task_status_precedence(src_own_status));
        else
            return (select avg(case when ch.id = src_id 
                                    then fix_task_progress_with_status(greatest(0, least(coalesce(ch.own_progress, 0), 100)), task_status_precedence(ch.own_status)) 
                                    else calc_task_progress(ch.id, ch.own_progress, ch.own_status, ch.has_sub_tasks)
                                    end) 
                        from task_task ch 
                        where     not ch.run_if_parent_task_failed 
                              and (ch.parent_task_id = src_id or ch.id = src_id));
        end if;
    end;
$$ language plpgsql;

        ''')


def revert_migration(apps, schema_editor):
    with connection.cursor() as cursor:
        cursor.execute('''
drop function calc_task_progress;
drop function fix_task_progress_with_status;
drop function calc_task_status;
drop function task_status_to_str;
drop function task_status_precedence;
drop extension hstore;

        ''')


class Migration(migrations.Migration):
    dependencies = [
        ('task', '0058_auto_20200323_1529'),
    ]

    operations = [
        migrations.RunPython(run_migration, reverse_code=revert_migration)
    ]
